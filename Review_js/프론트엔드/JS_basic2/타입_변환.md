# 타입 변환

자바스크립트에서 타입 변환을 이해하는 것은 매우 중요합니다. 어떤 경우에 데이터 타입 변환이 발생하는지를 알아야, 의도한 대로 동작하는 코드를 작성할 수 있습니다.

자바스크립트의 타입 변환은 명시적 강제 변환, 암시적 강제 변환 두 가지가 있습니다. 둘의 차이는 명확합니다.

명시적 강제 변환은 의도적인 타입 변환을 나타내는 것이고,
암시적 강제 변환은 표현식의 평가 중 타입이 변환되는 것입니다.

사실 명시적 강제 변환과 암시적 강제 변환의 기준은 사람마다 다를 수 있습니다. 타입 변환에 대해 꿰뚫고 있는 사람에겐 모든 타입 변환이 명시적 강제 변환으로 보일 것이고, 반대의 사람에겐 모두 암시적 강제 변환으로 보일 것입니다. 필자가 설명하는 명시적 강제 변환과 암시적 강제 변환의 기준은 여러분의 의견과 다를 수 있지만, 우선은 이 책의 관점에서 읽어보길 바랍니다.

## 명시적 강제 변환

명시적 강제 변환은 명확하게 의도를 갖고 타입을 변환하는 것입니다. 문자열, 숫자, 불리언 타입 별로 몇 가지 방법이 있습니다.

### 문자열로 변환

문자열로 변환하는 가장 간단한 방법은 [3.4장 랩퍼 객체]에서 보았던 String() 함수를 호출하는 것입니다. new 키워드를 붙이지 않고 String() 함수를 호출하면 랩퍼 객체를 생성하는 것이 아니라 타입 변환 한수로 동작합니다.

```javascript
console.log(String(3)); // '3'
console.log(String(false)); // 'false'
console.log(String(null)); // 'null'
```

그렇다면 다른 타입에서 문자열 타입으로의 변환은 어떤 기준으로 이뤄지는 걸까요?

타입별로 문자열 변환 방법이 정해져 있습니다. ECMAScript에서는 이 규칙을 ToString 추상 연산이라고 명시하고 있으며, 명시적이든 암시이든 문자열로 변환될 때 수행됩니다.

- NOTE: 정확히 말하면 String() 함수는 심볼 이외의 타입에 대해서 ToString 추상 연산을 따릅니다. 심볼 타입의 경우 SymbolDescriptiveString 연산을 통해 변환됩니다.

undefined => 'undefined'
null => 'null'
boolean => true -> 'true, false -> 'false'
number -> Number.toString()의 결과 반환(3 -> '3')
Symbol -> 문자열로 변환을 시도하는 경우 TypeError 발생
BigInt -> BigInt.toString(3n -> '3n')
object -> 객체를 원시 타입으로 변환한 후 다시 한번 ToString 추상 연산을 수행한 값을 반환합니다. 객체를 원시 타입으로 변환하는 과정을 정확히는 `ToPrimitive` 추상 연산이라고 합니다. 4.1.2장 참고.

```javascript
const boolVal = "ture";
const numVal = 2;

console.log(String(boolVal)); // 'true'
console.log(String(numVal)); // '2'
```

또 다른 문자열 변환 방법은 `toString()` 메서드를 사용하는 것입니다.

#### String()과 toString()의 차이점

앞서 살펴본 String()과 toString()은 대부분 동일한 결과를 반환하지만, 그렇지 않은 경우도 있습니다. null과 undefined 타입이 그에 해당합니다.

```javascript
console.log(String(null)); // 'null'
console.log(String(undefined)); // 'undefined'

undefined.toString(); // TypeError 발생
null.toString(); // TypeError 발생
```

예제 코드의 결과는 당연합니다. null 과 undefined는 타입은 값이 비어 있음, 할당되지 않은 상태를 나타내는 원시 타입이므로 toString() 메서드를 호출할 수 있다면 논리상 말이 되지 않습니다. 또한 이 타입들은 객체가 아니기 때문에 객체에서 사용할 수 있는 프로퍼티들을 사용할 수 없는 것이 옳습니다. 반면, String()함수의 경우 심볼 이외의 모든 타입이 [표4.1]에 정의된 규칙을 정확하게 따르기 때문에 문자열로 명시적 강제 변환을 하고 싶은 경우에는 toString() 메서드보단 String() 함수를 사용하는 것이 적합합니다.

### 숫자로 변환

- Number()
- parseInt()

숫자로의 변환도 문자열과 유사하게 Number() 함수를 호출하여 변환하는 방법이 있으며, BigInt 타입을 제외한 데이터는 ECMAScript의 ToNumber 추상 연산 명세를 기준으로 변환됩니다.

- NOTE: 숫자로의 변환 시 정확히는 ToNumber 추상 연산 명세를 기준으로 하며, 여기서 몇 가지 단계를 거쳐 ToNumber 추상 연산을 실행합니다. 이 책에서는 쉬운 이해를 위해 굉장히 축약하여 설명하였습니다.

undefined: NaN
null: +0
string: 숫자로 변경이 불가능한 값 -> NaN, 숫자형 문자열 -> 숫자
boolean: true -> 1 / false -> 2
Symbol: 숫자로 변환을 시도하는 경우 TypeError 발생
BigInt: 숫자로 변환을 시도하는 경우 TypeError 발생
object: 객체를 원시 타입으로 변환한 후 다시 한 번 ToNumber 추상 연산을 수행한 값을 반환합니다.

- NOTE: BigInt 타입은 숫자로 변환되는 것을 방지하기 위해 TypeError를 발생시킵니다. BigInt 타입은 숫자 타입과는 다르게 큰 정수(안전한 숫자 타입의 범위를 벗어나는 정수)의 연산을 위해 나온 타입이기 때문에 숫자와는 타입이 구분되어야 합니다.

#### parseInt()

숫자로 변환하는 또 다른 방법으로는 parseInt() 함수를 이용하는 방법이 있습니다. 다만, `parseInt() 함수는 문자열만 대상으로 변환`합니다. 값이 문자열이 아닌 경우에는 해당 값을 문자열로 변환한 후 사용합니다. 문자열의 변환 과정은 ToString 추상 연산 과정을 따릅니다.

```javascript
console.log(parseInt("10", 10)); // 10
console.log(parseInt("-1", 10)); // -1
```

parseInt() 함수의 두 번째 인자는 기수를 의미합니다. 예제 코드는 기수를 10으로 지정하였기 때문에 10진수를 기준으로 문자열을 숫자로 변환합니다. 기수를 생략하면 첫 번째 인자를 기준으로 추정하여 변환하므로 의도하지 않은 결과가 나올 수 있습니다. 버그를 만들고 싶지 않다면 반드시 기수를 지정하여 사용하길 권장합니다.

parseInt()함수는 Number() 함수와는 달리 인내심을 가지고 끝까지 변환을 수행합니다.

```javascript
console.log(Number("10A", 10)); // NaN
console.log(ParseInt("10A", 10)); // 10
```

Number()의 경우 숫자로 변경 불가능한 문자가 있으면 곧바로 NaN을 반환하지만, parseInt() 함수는 변경 불가능한 문자가 나타날 때까지 최대한 숫자로 변환하여 결과를 반환합니다.

### 불리언으로 변환

Boolean도 ECMAScript의 ToBoolean 추상 연산에 따라 타입을 변환합니다.

undefined: false
null: false
string: 빈 문자열 -> false / 그 외 문자열 -> true
number: +0, -0, NaN -> false / 그 외 숫자 -> true
Symbol: true
BigInt: 0n -> false / 그 외 BigInt 정수 -> true
object: true

falsy 값을 기억하십니까?
