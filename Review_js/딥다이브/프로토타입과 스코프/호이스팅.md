# 호이스팅

스코프 안에 변수를 선언하였을 때 발생하는 호이스팅이라는 동작.
이때 호이스팅이란 "선언문이 스코프 내의 최상단으로 끌어올려지는 것을 의미"한다.

(1)

```javascript
console.log(a); // undefined
var a = 1;
```

전역 스코프 내의 변수 a를 선언하기 전에 console.log() 메서드에서 참조.
선언하기 전 접근하였으니 "ReferenceError: a is not defined" 에러가 발생?

NO! undefined가 출력된다.

왜 이런 현상이 일어날까? 바로 호이스팅!
선언문 var a; 가 전역 스코프의 최상단으로 끌어올려지기 때문에 선언되기 이전에 참조할 수 있는 것.

[학습 목표]
호이스팅을 변수 생성 과정과 함께 살펴보자.

## 자바스크립트의 변수의 생성 과정 (선언 -> 초기화 -> 할당)

선언: 스코프에 변수를 선언합니다.
초기화: 변수의 값을 undefined 초기화, 실제로 변수에 접근 가능한 단계입니다.
할당: 할당문을 만나면 변수에 실제 값을 할당합니다.

참고 - var로 선언한 변수는 선언과 초기화 단계를 한 번에 실행한다.
그리고 이 두 단계는 스코프의 최상단으로 끌어올려져 실행된다.
따라서 선언하기 전에 변수에 접근하여도 이미 초기화가 되어 접근이 가능한 것이다.
이러한 동작을 호이스팅이라고 한다.

(2)

```javascript
var a;
console.log(a); // undefined
a = 1;
```

(1)의 예제가 실제 실행되는 과정은 (2)의 예제처럼 스코프의 최상단에서 변수 a의 선언과 초기화가 함께 실행된다.

## 스코프별로 동작하는 호이스팅

호이스팅은 스코프 별로 동작한다.
전역 스콮가 아닌 함수 내에 선언된 변수는 함수 스코프 안에서 호이스팅이 발생한다.

### let과 const (feat. TDZ)

let과 const 키워드로 선언한 변수는 var 키워드와 다르게 [선언과 초기화 단계가 분리되어 실행]된다.
선언 단계는 최상단으로 끌어올려져 실행된다. 하지만 초기화 단계는 선언문을 만나면 실행된다.
그리고 초기화 단계 이전에 변수에 접근하려고 하면 ReferenceError가 발생한다.

즉, 선언 단계가 실행되는 스코프의 최상단부터 초기화 단계를 실행하는 선언문이 나오기 전까지는 변수에 접근할 수 없다.
이 구간을 Temporal Dead Zone(TDZ)라고 부른다.

#### 선언은 끌어올려진다.

let 과 const 키워드로 선언한 변수의 초기화는 선언문을 만나는 시점에 실행된다.
선언 단계는 스코프의 최상단으로 끌어올려져 실행된다.

### 함수 선언문의 호이스팅

함수 선언문 역시 선언문이다. 그러므로 호이스팅이 발생한다.
다만, 함수 선언문의 호이스팅은 [변수 선언, 초기화, 할당] 세 가지 단계가 모두 스코프 최상단에서 실행된다.

```javascript
console.log(a());

function a() {
    console.log(1);
}
```
