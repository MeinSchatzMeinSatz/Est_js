# 리액트 개발자가 알아두여야 할 자바스크립트

## 값을 저장하는 방식의 차이

원시 타입과 객체 타입의 가장 큰 차이점 : 값을 저장하는 방식의 차이.
값을 저장하는 방식의 차이가 동등 비교를 할 때 차이를 만드는 [원인]이 된다.

원시 타입
먼저, 원시 타입은 [불변 형태의 값]으로 저장된다. 그리고 이 값은 변수 할 당 시점에 메모리 영역을 차지하고 저장된다.

객체 타입
반면 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 원시 값과 다르게 [변경 가능한 상태]로 저장된다. 값을 복사할 때도 값이 아닌 참조를 전달하게 된다.

-   객체는 값을 저장하는 게 아니라 참조를 저장하기 때문에 앞서 동일하게 선언했던 객체라 하더라도 저장하는 순간 다른 참조를 바라보기 때문에 false를 반환하게 된다. 즉, 값은 같았을지언정 참조하는 곳이 다른 셈이다.

-   반면 참조를 전달하는 경우에는 이전에 원시값에서 했던 것과 같은 결과를 기대할 수 있다.

-   한편, 다음 예제에서 hello의 hi 변수는 변수명 및 각 변수명의 주소가 서로 다르지만 value가 가리키는 주소가 동일하다.
    즉, value의 값(여기서는 {greet: "hello world"})dl hello.greet = "something"과 같이 변경된다 하더라도 hi와 hello 비교는 언제나 true를 반환한다.

따라서 자바스크립트 개발자는 항상 객체 간에 비교가 발생하면, 이 객체 간의 비교는 우리가 이해하는 내용의 값이 같다 하더라도 결과는 대부분 true가 아닐 수 있다는 것을 인지해야 한다.

## 자바스크립트의 또 다른 비교 공식, Object.js

자바스크립트에서는 비교를 위한 또 한 가지 방법을 제공하는데, 바로 Object.is다. Object.is는 두 개의 인수를 받으며, 이 인수 두 개가 동일한지 확인하고 반환하는 메서드이다. Object.js가 ==나 ===와 다른 점은 다음과 같다.

-   == vs. Object.is: == 비교는 같음을 비교하기 전에 양쪽의 같은 타입이 아니라면 비교할 수 있도록 강제로 형 변환(type casting)을 한 후에 비교한다. 5 == '5' 와 같이 형변환 한 후에 값이 동일하다면 == true를 반환한다. 하지만 Object.is는 이러한 작업을 하지 않는다. 즉, ===와 동일하게 타입이 다르면 그냥 false다.

-   === vs. Object.is: 이 방법에도 차이가 있다. 다음 코드를 보면 알 수 있듯, Object.is가 좀 더 개발자가 기대하는 방식으로 정확히 비교한다.

Object.is 는 ES6에서 새롭게 도입된 비교 문법으로, 위와 같이 몇 가지 특별한 사항에서 동등 비교 ===가 가지는 한계를 극복하기 위해 만들어졌다. 그러나 여전히 객체 간 비교에 있어서는 자바스크립트의 특징으로 인해 ===과 동일하게 동작하는 것을 알 수 있다.

## 리액트에서의 동등 비교

그렇다면 리액트에서는 동등 비교가 어떻게 이루어질까? 리액트에서 사용하는 동등 비교는 ==나 ===가 아닌 Object.is다. Object.is는 ES6에서 제공하는 기능이기 때문에 리액트에서는 이를 구현할 폴리필(Polyfill)을 함께 사용한다.

다음은
