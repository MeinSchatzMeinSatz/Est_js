# 관계형 연산자

코드를 작성하다 보면 두 피연산자의 관계를 검증하고 싶을 떄가 있습니다. 두 값이 같은지, 한 값이 다른 값보다 큰지 검사해 관게가 성립하는지 알아보는 것입니다. 이럴 때 사용하는 연산을 `관계형 연산`이라고 합니다.

관계형 연산의 결과는 항상 불리언 값이며, 주로 조건문이나 반복문 내의 조건을 정의할 때 사용됩니다.

- 비교연산자
- 동등연산자
- in, instanceof 연산자

## 비교 연산자

비교 연산자는 수학에서 익숙하게 접했던 연산자일 것입니다. 두 피연산자의 값이 상대적인 순서를 판단하며 `숫자와 문자열의 순서`만 비교할 수 있습니다.

```javascript
console.log(1 < 2); // true
console.log("ab" <= "b");
```

자바스크립트의 문자열은 16비트 유니코드 값의 집합이므로 문자열 비교는 이 코드의 순서를 비교해 연산을 수행합니다. 나라별 언어마다 유니코드의 인코딩 순서가 다르고, 대소 문자를 구분하기 때문에 문자열을 비교할 때 이 부분을 유의해야 합니다.

## 동등 연산자

동등 연산자는 값의 동등함을 판단하는 연산자입니다. 자바스크립트에서는 `일반적인 동등 연산자(==)`와 `엄격한 동등 연산자(===)` 두 가지로 동등함을 판단할 수 있습니다. 먼저 동등 연산자부터 알아보겠습니다. 동등 연산자는 참조 값이 동일하거나 `피연산자들의 타입이 달라도 같은 값을 반환할 수 있다면 동등`하다고 판단합니다. 동등 연산자의 두 번째 특징은 많은 개발자가 자바스크립트의 골칫거리라고 생각하는 부분 중 하나입니다.

```javascript
console.log(1 == true); // true
```

숫자 1과 불리언 값 true가 동등하다는 결과가 나왔습니다. 이러한 결과가 나오는 이유는 불리언 true가 숫자 1로 변환되어 같은 값을 반환하기 떄문입니다. 이 이상한 동작의 원리를 `암시적 강제 변환`이라고 합니다. 암시적 강제 변환은 연산 중에 내부적으로 타입을 변환해 연산을 수행하는 것을 의미합니다.

정리하자면 동등 연산자는 암시적 강제 변환을 통해 값의 타입을 변환해 비교하는 것입니다. 그렇다면 엄격한 동등 연산자와 일반 동등 연산자는 어떤 차이가 있을까요? `엄격한 동등 연산자는 암시적 강제 변환을 허용하지 않습니다.`

동등 연산자와 달리 타입 변환이 발생하지 않기 떄문에 타입이 다르다면 무조건 다른 값으로 판단합니다. 피연산자들의 타입과 값이 모두 일치해야 동등하다고 판단하기 때문에 '엄격한'이란 표현을 붙여서 사용하며 일치 연산자라고 합니다.

- NOTE: 엄격한 동등 연산의 결과가 동등하다고 판단되었다면, 당연히 동등 연산의 결과도 동등합니다.

## in, instanceof 연산자

in 연산자는 객체에 특정 프로퍼티가 있는지 확인하는 연산자이며, 우측에는 반드시 객체 타입이 와야 합니다. 좌측 평갓값이 우측 객체의 프로퍼티라면 참으로 판단하며, 아니라면 거짓으로 판단합니다.

```javascript
const obj = { a: 1, b: 2 };
console.log("a" in obj); // true
console.log("c" in obj); // false
```

instanceof 연산자는 좌측 피연산자가 우측 피연산자의 인스턴스인지 판단하는 연산자입니다. 우측에는 반드시 생성자 함수 또는 클래스가 와야 합니다. 좌측 평갓값이 우측 클래스의 인스턴스라면 참으로 판단하고 그렇지 않다면 거짓으로 판단합니다.

```javascript
const arr = [1, 2];

console.log(arr instanceof Array); // true
console.log(arr instanceof Date); // false
```

- NOTE: instanceof 연산자는 내부적으로 프로토타입 체인이라는 메커니즘으로 인스턴스인지 판단합니다. 프로토타입 체인에 대해서는 5장에서 자세히 봅시다.
